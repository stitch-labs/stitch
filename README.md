# stitch

*Stitch is an Incredibly fast EVM runtime emulator, bundler, test runner, and package manager â€“ all in one. It ships as a single executable called `stitch`.*

Stitch is not yet production-ready. In particular, the protocol and data file formats may change and [might not be compatible across different commits](https://github.com/stitch-labs/stitch/issues/1), while we fine-tune the format ahead of release.

The production version of **Stitch is not under active development**.


## Quickstart

On macOS/Linux:

```console
git clone https://github.com/stitch-labs/stitch; cd stitch; zig build; zig run src/stitch.zig;
```

â€‹â€‹The `stitch` command-line tool also implements a EVM runtime emulator, bundler, test runner, and github based package manager. Instead of manually linking for development, you only need `stitch`. Stitch's built-in tools are significantly faster than existing options and usable in existing ethereum projects with little to no changes.

```console
ðŸš€ What is Stitch?

ðŸ”µ Stitch is under active development. Use it to speed up
   your development workflows or run simpler production
   code in resource-constrained environments like localhost.
   We're working on more complete runtime compatibility and 
   integration with existing frameworks like foundry and hardhat.
   Join the [Discord](https://stitch-labs.sh/discord) and watch
   the [GitHub repository](https://github.com/stitch-labs/stitch)
   to keep tabs on future releases.

ðŸ§µ Stitch is an all-in-one toolkit for EVM Development.
   It ships as a single executable called `stitch`.

   At its core is the _Stitch runtime_, a fast EVM client
   designed as an EVM runtime written in Zig and powered by 
   StitchScriptCore under the hood,
   dramatically reducing startup times and memory usage.

ðŸ“¦ The `stitch` command-line tool also implements a test runner,
   script runner, and a light ethereum client. a novel package
   manager. Instead of 100 dev tools for development, you only
   need `stitch`. Stitch's built-in tools are significantly
   faster than existing options and usable in existing ethereum
   projects with little to no changes.

Usage: stitch [command] [options]

Commands:
 
  abi-spec                     Generates Zig bindings for an ABI specification .json
  abi-bytecode                 Generates the EVM bytecode bindings for an ABI specification .json

General Options:

  -h, --help       Print command-specific usage

Debug Commands:

  dump-bindings                Dump a file containing the cached EVM bytecode bindings
```

Lookout for the executable you should be using until bootstraping is supported, it will look something like this.
```bash
debug: Use /Users/christopher.bradley/.cache/zig/o/1f871e4643d84385e6d8a500bf67b162/stitch instead of the (stitch) command
```

Working Features:
  - abi-bytecode (Will save under `/src/autogen/bytecode/<Filename>`)
    ```console
    f((uint256,uint256[],(uint256,uint256)[]),(uint256,uint256),uint256)
    ```
  - spec-abi (Will save under `/src/autogen/specifications/abi.zig`)
    ```zig
    //This file is auto-generated by tools/gen_abi_spec.zig
    const Version = @import("std").SemanticVersion;
    pub const AbiFunctionType = enum(u8) {
        function = 0x0,
    };
    pub const AbiComponentType = enum(u8) {
        tuple = 0x10,
        uint256 = 0x11,
    };
    const AbiFunction = struct {
        name: []const u8,
        type: AbiFunctionType,
        inputs: []AbiComponent,
        outputs: []AbiComponent,
    };
    const AbiComponent = struct {
        name: []const u8,
        type: AbiComponentType,
        components: []AbiComponent,
    };
    ```

Partially Working:
- `zig test src/interpreter/sol/lexer.zig`

Input (located `/example/abi.json`)
```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;
pragma experimental ABIEncoderV2;

contract Example {
    struct S { uint a; uint[] b; T[] c; }
    struct T { uint x; uint y; }
    function f(S memory, T memory, uint) public pure {}
    function g() public pure returns (S memory, T memory, uint) {}
}
```


Output
```bash
(( SPDX-License-Identifier: GPL-3.0,  SPDX-License-Identifier: GPL-3.0), (3, 3))
((pragma, pragma), (34, 34))
((solidity, solidity), (35, 35))
((^, ^), (15, 15))
((0, 0), (101, 101))
((., .), (33, 33))
((8, 8), (101, 101))
((., .), (33, 33))
((0, 0), (101, 101))
((;, ;), (26, 26))
((pragma, pragma), (34, 34))
((experimental, experimental), (108, 108))
((ABIEncoderV2, ABIEncoderV2), (2, 2))
((;, ;), (26, 26))
((contract, contract), (36, 36))
((Example, Example), (2, 2))
(({, {), (29, 29))
((struct, struct), (92, 92))
((S, S), (2, 2))
(({, {), (29, 29))
((uint, uint), (101, 101))
((a, a), (2, 2))
((;, ;), (26, 26))
((uint, uint), (101, 101))
(([, [), (31, 31))
((], ]), (32, 32))
((b, b), (2, 2))
((;, ;), (26, 26))
((T, T), (2, 2))
(([, [), (31, 31))
((], ]), (32, 32))
((c, c), (2, 2))
((;, ;), (26, 26))
((}, }), (30, 30))
((struct, struct), (92, 92))
((T, T), (2, 2))
(({, {), (29, 29))
((uint, uint), (101, 101))
((x, x), (2, 2))
((;, ;), (26, 26))
((uint, uint), (101, 101))
((y, y), (2, 2))
((;, ;), (26, 26))
((}, }), (30, 30))
((function, function), (39, 39))
((f, f), (2, 2))
(((, (), (27, 27))
((S, S), (2, 2))
((memory, memory), (76, 76))
((,, ,), (25, 25))
((T, T), (2, 2))
((memory, memory), (76, 76))
((,, ,), (25, 25))
((uint, uint), (101, 101))
((), )), (28, 28))
((public, public), (82, 82))
((pure, pure), (83, 83))
(({, {), (29, 29))
((}, }), (30, 30))
((function, function), (39, 39))
((g, g), (2, 2))
(((, (), (27, 27))
((), )), (28, 28))
```
