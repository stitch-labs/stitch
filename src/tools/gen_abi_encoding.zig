const std = @import("std");
const ag = @import("abi/grammar.zig");
const Allocator = std.mem.Allocator;

const ExtendedStructSet = std.StringHashMap(void);

const auto_generated_tag =
    \\//This file is auto-generated by tools/gen_abi_encoding.zig
    \\===========================================================
;

const usage =
    \\Usage: stitch encode-abi <abi .json>
    \\
    \\Generates EVM bytecode for an ABI specification .json (either core or
    \\extinst versions). The result, printed to stdout, should be used to update
    \\files in src/codegen/bytecode. Don't forget to format the output.
    \\
    \\The relevant specifications can be obtained from the Stitch Registry
    \\https://github.com/registry.stitch.com/
    \\
;

fn write_bytes_to_file(file: std.fs.File, allocator: Allocator, comptime fmt: []const u8, args: anytype) !void {
    var bytes = try std.fmt.allocPrint(
        allocator,
        fmt,
        args,
    );
    const bytes_written = try file.write(bytes);
    _ = bytes_written;
    defer allocator.free(bytes);
}

pub fn render(writer: anytype, allocator: Allocator, registry: ag.CoreRegistry) !void {
    _ = writer;

    const file = try std.fs.cwd().createFile(
        "src/codegen/abi/bytecode.txt",
        .{ .read = true },
    );
    defer file.close();

    try write_bytes_to_file(
        file,
        allocator,
        "{s}\n",
        .{auto_generated_tag},
    );

    for (0.., registry.contract_abi) |i, function| {
        _ = i;

        if (function.type == ag.AbiFunctionType.function) {
            var input_list_len: usize = function.inputs.len;
            _ = input_list_len;
            var output_list_len: usize = function.outputs.len;
            _ = output_list_len;

            try write_bytes_to_file(
                file,
                allocator,
                "{s}()\n",
                .{function.name},
            );
        }
    }
}

pub fn print_usage() void {
    std.log.info("{s}", .{usage});
}
