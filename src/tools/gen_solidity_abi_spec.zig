const std = @import("std");
const sag = @import("solidity/abi/grammar.zig");
const Allocator = std.mem.Allocator;
const print = std.debug.print;

const ExtendedStructSet = std.StringHashMap(void);

pub fn main() !void {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();
    const allocator = arena.allocator();

    const args = try std.process.argsAlloc(allocator);
    if (args.len != 2) {
        print_usage_and_exit(std.io.getStdErr(), args[0], 1);
    }

    const spec_path = args[1];
    const spec = try std.fs.cwd().readFileAlloc(allocator, spec_path, std.math.maxInt(usize));

    // Required for json parsing.
    @setEvalBranchQuota(10000);

    var scanner = std.json.Scanner.initCompleteInput(allocator, spec);
    var diagnostics = std.json.Diagnostics{};
    scanner.enableDiagnostics(&diagnostics);
    var parsed = std.json.parseFromTokenSource(sag.CoreRegistry, allocator, &scanner, .{}) catch |err| {
        std.debug.print("line,col: {},{}\n", .{ diagnostics.getLine(), diagnostics.getColumn() });
        return err;
    };

    var bw = std.io.bufferedWriter(std.io.getStdOut().writer());
    try render(bw.writer(), allocator, parsed.value);
    try bw.flush();
}

pub fn render(writer: anytype, allocator: Allocator, registry: sag.CoreRegistry) !void {
    _ = allocator;

    try writer.writeAll(
        \\//! This file is auto-generated by epm/tools/gen_solidity_abi_spec.zig
        \\
        \\
    );

    try writer.print(
        \\pragma solidity ^{}.{}.{}
        \\
        \\contract {s} {{
        \\
    ,
        .{ registry.major_version, registry.minor_version, registry.revision, registry.magic_number },
    );

    for (0.., registry.contract_abi) |i, function| {
        _ = i;

        if (function.type == sag.AbiFunctionType.function) {
            var input_list_len: usize = function.inputs.len;
            var output_list_len: usize = function.outputs.len;

            try writer.print(
                \\      function {s}()
            ,
                .{function.name},
            );

            if (input_list_len == 0) {
                if (input_list_len == output_list_len) {
                    try writer.print(
                        \\ public pure
                    ,
                        .{},
                    );
                }
            }

            try writer.print(
                \\ {{}}
            ,
                .{},
            );
        }

        // if (function.type == sag.AbiFunctionType[@intFromEnum(sag.AbiFunctionType.function)]) {
        //     try writer.print(
        //         \\
        //         \\ struct {{
        //         \\
        //     ,
        //         .{},
        //     );

        //     for (0.., function.inputs) |j, input| {
        //         _ = j;

        //         try writer.print(
        //             \\    {} {s};
        //         ,
        //             .{ input.type, input.name },
        //         );
        //     }

        //     try writer.print(
        //         \\ }}
        //         \\
        //     , .{});
        // }
    }

    try writer.print(
        \\
        \\}}
        \\
        \\
    ,
        .{},
    );
}

fn print_usage_and_exit(file: std.fs.File, arg0: []const u8, code: u8) noreturn {
    file.writer().print(
        \\Usage: {s} <solidity json spec>
        \\
        \\Generates Zig bindings for a Solidity specification .json (either core or
        \\extinst versions). The result, printed to stdout, should be used to update
        \\files in src/codegen/solidity. Don't forget to format the output.
        \\
        \\The relevant specifications can be obtained from the Ansible manifest:
        \\https://github.com/xchrisbradley/epm-headers/blob/master/include/universal
        \\
    , .{arg0}) catch std.process.exit(1);
    std.process.exit(code);
}
